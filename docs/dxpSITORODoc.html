<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>dxpSITORO - EPICS software for XIA FalconX Digital Signal Processing Systems
  </title>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type" />
</head>
<body>
  <div style="text-align: center">
    <h1>
      dxpSITORO - EPICS software for XIA FalconX Digital Signal Processing Systems</h1>
    <h2>
      Release 1-1</h2>
    <h2>
      July 16, 2017</h2>
    <h2>
      Mark Rivers</h2>
    <h2>
      University of Chicago</h2>
  </div>
  <hr />
  <h2>
    Contents</h2>
  <ul>
    <li><a href="#Overview">Overview</a></li>
    <li><a href="#Architecture">Architecture</a></li>
    <li><a href="#EPICS_Records">EPICS Records, Databases, and medm screens</a>
      <ul>
        <li><a href="#dxpHighLevel">dxpHighLevel.template</a></li>
        <li><a href="#dxpSCA">dxpSCA.template</a></li>
        <li><a href="#dxpSystem">dxpSystem.template</a></li>
        <li><a href="#dxpMED">dxpMED.template</a></li>
        <li><a href="#dxpMapping">dxpMapping.template</a></li>
      </ul>
    </li>
    <li><a href="#medm">medm screens</a></li>
    <li><a href="#Installing">Installing dxpSITORO</a></li>
  </ul>
  <h2 id="Overview">
    Overview</h2>
  <p>
    The EPICS dxpSITORO module provides support for the SITORO based digital signal
    processor based multichannel analyzers from <a href="http://www.xia.com">X-ray Instrumentation
      Associates (XIA)</a>. These devices include the FalconXN models, and all contain
    the functional equivalent of the shaping amplifier, ADC, and MCA of a conventional
    pulse-height analysis system. The FalconX is based on the SITORO technology from
    <a href="http://southerninnovation.com/products/">Southern Innovation</a>
  </p>
  <p>
    dxpSITORO supports the 1, 4, and 8 channel versions of the FalconX.</p>
  <p>
    dxpSITORO currently supports this hardware under the following operating systems
    and compilers:</p>
  <ul>
    <li>Linux with gcc.</li>
    <li>Windows with Visual Studio 2015 or later.</li>
  </ul>
  <p>
    The features of the EPICS software, compared with the ProSpect software available
    from XIA are:</p>
  <ul>
    <li>Control and data acquisition are available over the network, from any application
      or language that supports the EPICS Channel Access protocol (based on TCP/IP). This
      means that EPICS clients written in languages like Python, IDL, LabView, etc. can
      control the FalconX modules and read the data. These applications can be running
      on any computer on the Internet, they do not need to run on the computer that is
      controlling to the XIA hardware. This client/server model is very desirable in complex
      data acquisition environments, such as synchrotron beamlines, because it allows
      the FalconX control and data acquisition to be integrated with other hardware and
      software. For example, a control software program can move a motor, command the
      FalconX to acquire data, and write the data to disk.</li>
  </ul>
  <h2 id="Architecture">
    Architecture</h2>
  <p>
    The software consists of the following components:</p>
  <ul>
    <li>An <a href="http://www.aps.anl.gov/epics/modules/soft/asyn/">asyn port driver</a>.
      This driver is implements a class called <a href="dxpDoxygenHTML/class_n_d_dxp.html">
        NDDxp</a>, which is derived from the <a href="https://cars.uchicago.edu/software/epics/areaDetectorDoc.html#asynNDArrayDriver">
          asynNDArrayDriver</a> and <a href="http://www.aps.anl.gov/epics/modules/soft/asyn/R4-31/asynPortDriver.html">
            asynPortDriver</a> base C++ classes. The driver communicates with the hardware
      using the <a href="falconxn.pdf">XIA Handel library</a>, which in turn communicates
      with the Southern Innovation SINC library. </li>
    <li>An EPICS <a href="https://cars.uchicago.edu/software/epics/mcaRecord.html">MCA
      record</a> for each detector. This communicates with the driver via the asyn MCA
      device support. This support allows each detector to be treated identically with
      other supported MCA hardware, such as the Canberra AIM. The MCA record is used for
      data acquisition in the non-mapping modes, and to define regions of interest.</li>
    <li>A set of standard EPICS records (ai, ao, bi, bo, waveform, etc.) that are used
      to set all of the many software selectable parameters for the FalconX, including
      pulse separation, detection threshold, etc. These are also used for data acquisition
      in the mapping modes and to acquire diagnostic data, such as the ADC trace. These
      records use the standard asyn device support.</li>
    <li>A State Notation Language program (dxpMED) for synchronizing acquisition, ROIs,
      and FalconX parameters in multi-element detector systems.</li>
    <li>Support for the plugins from the <a href="https://cars.uchicago.edu/software/epics/areaDetector.html">
      areaDetector</a> package. These plugins are used to stream data to disk in the mappping
      modes, to define ROIs, compute statistics, etc.</li>
    <li>Databases for single-element and multi-element detector systems.</li>
    <li>medm display screens.</li>
    <li>Example IOC boot directories for the FalconX.</li>
  </ul>
  <p>
    The overall architecture of the EPICS dxpSITORO software is shown in the diagram
    below. At the top level are EPICS Channel Access client applications, such as the
    IDL MCA Display program, the Python Multi-Element Detector control programs, medm,
    spec, and others.</p>
  <p style="text-align: center">
    <img alt="dxpSITOROFlowchart.png" src="dxpSITOROFlowchart.png" /></p>
  <h2 id="EPICS_Records">
    EPICS Records and Databases</h2>
  <p>
    This document does not attempt to explain the meaning or use of all of the FalconX
    parameters. The best documentation of the operation of the FalconX modules is provided
    by XIA in the <a href="FalconXn_QSG.pdf">FalconX Quick Start Guide</a>. This also
    describes the ProSpect software, which is useful to set up and test the hardware.</p>
  <p>
    For many parameters in the following databases there is both an EPICS output record
    (ao, bo, mbbo, etc.) and a corresponding EPICS input record (ai, bi, mbbi, etc.).
    The output record is used to set a new value in the hardware. The input record has
    an _RBV suffix, which stands for Read Back Value. It is used to read back the actual
    value from the hardware, which may be different from the requested value because
    of limitations of the hardware, errors, etc.</p>
  <p>
    When the EPICS IOC starts the initial values of the records are set in the following
    order:</p>
  <ol>
    <li>The default value in the record definition, typically 0.</li>
    <li>The value specified in the database file (.template or .substitutions file)</li>
    <li>The value read back from the hardware or Handel library. This will be the Handel
      default value, or the value from the .ini file if it is defined there.</li>
    <li>The value from save/restore.</li>
    <li>The value from a "dbpf" in the startup script.</li>
    <li>The value set from the SNL program on startup.</li>
  </ol>
  <p>
    Steps 1-3 apply to both output records and to input records. Steps 4 and 5 typically
    only apply to output records, and step 7 only to input records. If there is no auto_settings*.sav
    file then most of the parameter records will obtain their initial values from the
    .ini file. Thus, by deleting the auto_settings*.sav file one can force EPICS to
    use the same parameters that have been saved into an .ini file by ProSpect.</p>
  <h3 id="dxpHighLevel">
    dxpHighLevel.template</h3>
  <p>
    The following records are defined in the database dxpHighLevel.template. They control
    the high-level parameters such as peaking time, etc. One instance of this database
    is loaded for each detector channel in the system. All of the record names in the
    template file are preceeded by the macro parameters $(P)$(R), where $(P) is the
    prefix for this detector system, and $(R) is the name of this specific channel.
    $(P) should be unique for all EPICS IOCs on the subnet, and $(R) is typically dxp1:,
    dxp2:, etc.</p>
  <table border="1" cellpadding="5">
    <tbody>
      <tr>
        <td align="center" colspan="3">
          <b>Records in dxpHighLevel.template</b>
        </td>
      </tr>
      <tr>
        <th>
          Record Name
        </th>
        <th>
          Record Type
        </th>
        <th>
          Description
        </th>
      </tr>
      <tr>
        <td align="center" colspan="3">
          <b>Detection Records</b>
        </td>
      </tr>
      <tr valign="top">
        <td>
          DetectionFilter<br />
          DetectionFilter_RBV
        </td>
        <td>
          mbbo<br />
          mbbi
        </td>
        <td>
          The detection filter type. Choices are:
          <ul>
            <li>LowEnergy</li>
            <li>LowRate</li>
            <li>MidRate</li>
            <li>HighRate</li>
            <li>MaxThroughput</li>
          </ul>
          .
        </td>
      </tr>
      <tr valign="top">
        <td>
          DetectionThreshold<br />
          DetectionThreshold_RBV
        </td>
        <td>
          ao<br />
          ai
        </td>
        <td>
          The threshold in keV (?).
        </td>
      </tr>
      <tr valign="top">
        <td>
          MinPulsePairSeparation<br />
          MinPulsePairSeparation_RBV
        </td>
        <td>
          longout<br />
          longout
        </td>
        <td>
          The minimum number of samples between pulses.
        </td>
      </tr>
      <tr>
        <td align="center" colspan="3">
          <b>Pre-amp and Energy Range Records</b>
        </td>
      </tr>
      <tr valign="top">
        <td>
          DetectorPolarity<br />
          DetectorPolarity_RBV
        </td>
        <td>
          bo<br />
          bi
        </td>
        <td>
          Pre-amp polarity (not high-voltage polarity). 0=Neg, 1=Pos. Positive polarity means
          an x-ray pulse causes an increase in the pre-amp voltage output. This is normally
          defined in the .ini file, but is accessible to EPICS to allow quick determination
          of the correct polarity.
        </td>
      </tr>
      <tr valign="top">
        <td>
          ResetDelay<br />
          ResetDelay_RBV
        </td>
        <td>
          ao<br />
          ai
        </td>
        <td>
          For reset pre-amps the time in microseconds to recover after a pre-amp reset.
        </td>
      </tr>
      <tr valign="top">
        <td>
          DecayTime<br />
          DecayTime_RBV
        </td>
        <td>
          ao<br />
          ai
        </td>
        <td>
          For RC pre-amps the characteristic decay time in microseconds.
        </td>
      </tr>
      <tr valign="top">
        <td>
          ScaleFactor<br />
          ScaleFactor_RBV
        </td>
        <td>
          ao<br />
          ai
        </td>
        <td>
          Scale factor to control the energy range of the spectra.
        </td>
      </tr>
      <tr valign="top">
        <td>
          RisetimeOptimization<br />
          RisetimeOptimization_RBV
        </td>
        <td>
          ao<br />
          ai
        </td>
        <td>
          Risetime optimization factor for the pre-amp signal. Range is 0 to 4000.
        </td>
      </tr>
      <tr>
        <td align="center" colspan="3">
          <b>Preset Counting Records</b>
        </td>
      </tr>
      <tr valign="top">
        <td>
          PresetMode<br />
          PresetMode_RBV
        </td>
        <td>
          mbbo<br />
          mbbi
        </td>
        <td>
          The preset counting mode. The choices are:
          <ul>
            <li>"No preset" Count until acquisition is stopped manually.</li>
            <li>"Real time" Count for a preset real time.</li>
            <li>"Events" The preset number of events is set by the PresetEvents record.</li>
            <li>"Triggers" The preset number of triggers is set by the PresetTriggers record.</li>
          </ul>
          The preset real time and preset live time are controlled by the .PRTM and .PLTM
          fields of the corresponding MCA record.
        </td>
      </tr>
      <tr valign="top">
        <td>
          PresetReal<br />
          PresetReal_RBV
        </td>
        <td>
          ao<br />
          ai
        </td>
        <td>
          The real time in seconds count for.
        </td>
      </tr>
      <tr valign="top">
        <td>
          PresetEvents<br />
          PresetEvents_RBV
        </td>
        <td>
          longout<br />
          longin
        </td>
        <td>
          The number of events to count for.
        </td>
      </tr>
      <tr valign="top">
        <td>
          PresetTriggers<br />
          PresetTriggers_RBV
        </td>
        <td>
          longout<br />
          longin
        </td>
        <td>
          The number of triggers to count for. Triggers are x-rays that were processed by
          the trigger filter, and includes pileups and other events that are not actually
          present in the spectrum.
        </td>
      </tr>
      <tr>
        <td align="center" colspan="3">
          <b>Counting Statistics Records</b>
        </td>
      </tr>
      <tr valign="top">
        <td>
          ElapsedRealTime
        </td>
        <td>
          ai
        </td>
        <td>
          The elapsed real time. This is the same information as in the .ERTM field of the
          corresponding MCA record.
        </td>
      </tr>
      <tr valign="top">
        <td>
          ElapsedLiveTime
        </td>
        <td>
          ai
        </td>
        <td>
          The elapsed live time. This is the same information as in the .ELTM field of the
          corresponding MCA record.
        </td>
      </tr>
      <tr valign="top">
        <td>
          ElapsedTriggerLiveTime
        </td>
        <td>
          ai
        </td>
        <td>
          The elapsed live time for the trigger filter.
        </td>
      </tr>
      <tr valign="top">
        <td>
          Triggers
        </td>
        <td>
          longin
        </td>
        <td>
          The number of trigger filter events.
        </td>
      </tr>
      <tr valign="top">
        <td>
          Events
        </td>
        <td>
          longin
        </td>
        <td>
          The number of energy filter events.
        </td>
      </tr>
      <tr valign="top">
        <td>
          InputCountRate
        </td>
        <td>
          ai
        </td>
        <td>
          The input count rate (ICR), which is the same as Triggers/ElapsedTriggerLiveTime.
        </td>
      </tr>
      <tr valign="top">
        <td>
          OutputCountRate
        </td>
        <td>
          ai
        </td>
        <td>
          The output count rate (OCR), which is the same as Events/ElapsedRealTime.
        </td>
      </tr>
      <tr>
        <td align="center" colspan="3">
          <b>Mapping Records</b>
        </td>
      </tr>
      <tr valign="top">
        <td>
          CurrentPixel
        </td>
        <td>
          longin
        </td>
        <td>
          The current pixel in the mapping run in MCA mapping mode.
        </td>
      </tr>
      <tr>
        <td align="center" colspan="3">
          <b>Diagnostic Trace Records</b>
        </td>
      </tr>
      <tr valign="top">
        <td>
          TraceData
        </td>
        <td>
          waveform
        </td>
        <td>
          The diagnostic trace data. The array is read from the hardware when this record
          is processed. <i>Note: this record should not be processed while normal data acquisition
            is in progress or it will slow things down.</i>
        </td>
      </tr>
    </tbody>
  </table>
  <h3 id="dxpSCA">
    dxpSCA.template</h3>
  <p>
    The following records are defined in the databases dxpSCA.template. They control
    the 16 (FalconX1), 4 (FalconX4) or 2 (FalconX8) single-channel-analyzers (SCAs)
    for each channel. Each SCA is defined by a low channel and a high channel. The SCA
    definitions are for hardware ROI mapping. The FalconX puts out a pulse on a TTL
    output line when an x-ray falls within the channel range of that SCA. This allows
    very fast mapping, since there is no need to read the spectrum at each point in
    the scan.</p>
  <p>
    One instance of this database is loaded for each SCA and each detector channel in
    the system. All of the record names in the template file are preceeded by the macro
    parameters $(P)$(R), where $(P) is the prefix for this detector system, and $(R)
    is the name of this specific channel. The macro $(N) is used to define the SCA number.</p>
  <table border="1" cellpadding="5">
    <tbody>
      <tr>
        <td align="center" colspan="3">
          <b>Records in dxpSCA.template</b>
        </td>
      </tr>
      <tr>
        <th>
          Record Name
        </th>
        <th>
          Record Type
        </th>
        <th>
          Description
        </th>
      </tr>
      <tr valign="top">
        <td>
          SCA$(N)Low<br />
          SCA$(N)Low_RBV
        </td>
        <td>
          longout<br />
          longin
        </td>
        <td>
          The low channel for SCA $(N). Actual record names are SCA0Low, SCA1Low, etc.
        </td>
      </tr>
      <tr valign="top">
        <td>
          SCA$(N)High<br />
          SCA$(N)High_RBV
        </td>
        <td>
          longout<br />
          longin
        </td>
        <td>
          The high channel for SCA $(N). Actual record names are SCA0High, SCA1High, etc.
        </td>
      </tr>
    </tbody>
  </table>
  <h3 id="dxpSystem">
    dxpSystem.template</h3>
  <p>
    The following records are defined in the database dxpSystem.template. One instance
    of this database is loaded for each FalconX system, since they control system-wide
    parameters. All of the record names in the template file are preceeded by the macro
    parameter $(P), the prefix for this detector system.</p>
  <table border="1" cellpadding="5">
    <tbody>
      <tr>
        <td align="center" colspan="3">
          <b>Records in dxpSystem.template</b>
        </td>
      </tr>
      <tr>
        <th>
          Record Name
        </th>
        <th>
          Record Type
        </th>
        <th>
          Description
        </th>
      </tr>
      <tr valign="top">
        <td>
          TraceTime
        </td>
        <td>
          ai
        </td>
        <td>
          The time per sample in microseconds for the TraceData arrays.
        </td>
      </tr>
      <tr valign="top">
        <td>
          TraceTimeArray
        </td>
        <td>
          waveform
        </td>
        <td>
          The time values for the trace data. This array is used to provide a calibrated X-axis
          when plotting the TraceData.
        </td>
      </tr>
      <tr valign="top">
        <td>
          MaxSCAs
        </td>
        <td>
          longin
        </td>
        <td>
          The maximum number of SCAs that the system supports.
        </td>
      </tr>
      <tr valign="top">
        <td>
          NumSCAs<br />
          NumSCAs_RBV
        </td>
        <td>
          longout<br />
          longin
        </td>
        <td>
          The number of SCAs (ROIs) to use. The records for each SCA are defined in the database
          dxpSCA.template.
        </td>
      </tr>
      <tr valign="top">
        <td>
          SCATriggerMode<br />
          SCATriggerMode_RBV
        </td>
        <td>
          mboo<br />
          mbbi
        </td>
        <td>
          The SCA trigger mode, which controls when the FalconX outputs SCA pulses. The choices
          are:
          <ul>
            <li>0: Off </li>
            <li>1: Gate high </li>
            <li>2: Gate low </li>
            <li>2: Always </li>
          </ul>
        </td>
      </tr>
      <tr valign="top">
        <td>
          SCAPulseDuration<br />
          SCAPulseDurection_RBV
        </td>
        <td>
          longout<br />
          longin
        </td>
        <td>
          The duration (width) of the SCA pulse oututs in ns.
        </td>
      </tr>
      <tr valign="top">
        <td>
          PollTime<br />
          PollTime_RBV
        </td>
        <td>
          bo<br />
          ao
        </td>
        <td>
          The EPICS driver rapidly polls the hardware when acquisition is active to detect
          when acquisition is complete. This record controls the poll time, which is typically
          .001 to .01 seconds. Decreasing the time decreases latency at the expense of more
          CPU time, and there is a minimum time required to poll the hardware.
        </td>
      </tr>
      <tr valign="top">
        <td>
          SaveSystemFile
        </td>
        <td>
          waveform
        </td>
        <td>
          The name of a file in which to save the system information. This file is created
          by the XIA Handel software, and is the ".ini" file format used in the call to xiaInit()
          in the startup script. This file can be used to transfer settings between XIA's
          ProSpect program and EPICS. This is a waveform record with type DBF_UCHAR and length
          256, rather than a stringout record, so that file paths/names longer than 40 characters
          can be used. Client applications must convert the file name to an unsigned char
          array when writing to this field.
        </td>
      </tr>
      <tr valign="top">
        <td>
          SaveSystem<br />
          SaveSystem_RBV
        </td>
        <td>
          bo<br />
          bi
        </td>
        <td>
          Writing 1 to this record causes the system information to be written to the file
          specified by SaveSystemFile.
        </td>
      </tr>
      <tr valign="top">
        <td>
          EnableClientWait
        </td>
        <td>
          bo
        </td>
        <td>
          This record enables waiting for a client when acquisition completes. It can be used
          to wait for a client application to save data to disk, etc.
        </td>
      </tr>
      <tr valign="top">
        <td>
          SetClientWait
        </td>
        <td>
          bo
        </td>
        <td>
          This record sets the ClientWait record to Busy if EnableClientWait is set to Enable.
          This record is processed by EraseStart and StartAll in the dxpMED.template database.
        </td>
      </tr>
      <tr valign="top">
        <td>
          ClientWait
        </td>
        <td>
          busy
        </td>
        <td>
          This record forces processing to wait until a client clears it after acquisition
          starts when EnableClientWait is set to Enable.
        </td>
      </tr>
    </tbody>
  </table>
  <h3 id="dxpMED">
    dxpMED.template</h3>
  <p>
    The following records are defined in the database dxpMED.template (MED stands for
    Multi-Element Detector). One instance of this database is loaded for each system,
    since they control system-wide parameters. Only the records in this database that
    are intended for use by EPICS clients are documented here. Records that are not
    intended to be accessed from clients are not documented, since they may be changed
    in the future. Records in this database are implemented in several ways. Some are
    connected to an MCA record that is configured with a special address that signifies
    that it controls all detector channels. That record communicates directly with the
    driver. Other records are implemented in a State Notation Language program which
    monitors the system-wide records like PresetMode, and copies them to the individual
    detector records.</p>
  <p>
    All of the record names in the template file are preceeded by the macro parameter
    $(P), the prefix for this detector system.</p>
  <table border="1" cellpadding="5">
    <tbody>
      <tr>
        <td align="center" colspan="3">
          <b>Records in dxpMED.template</b>
        </td>
      </tr>
      <tr>
        <th>
          Record Name
        </th>
        <th>
          Record Type
        </th>
        <th>
          Description
        </th>
      </tr>
      <tr>
        <td align="center" colspan="3">
          <b>SNL Status Records</b>
        </td>
      </tr>
      <tr valign="top">
        <td>
          SNL_Connected
        </td>
        <td>
          bi
        </td>
        <td>
          This record will be 1 ("Connected") when the SNL program has connected to all of
          the PVs. If it is 0 ("Not connected") then there is a problem with the SNL program.
        </td>
      </tr>
      <tr>
        <td align="center" colspan="3">
          <b>Acquisition Control Records</b>
        </td>
      </tr>
      <tr valign="top">
        <td>
          EraseAll
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record erases all of the MCA records in this system.
        </td>
      </tr>
      <tr valign="top">
        <td>
          EraseStart
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record erases and starts acquisition on all of the MCA records
          in this system. In the mapping modes it starts a new mapping run.
        </td>
      </tr>
      <tr valign="top">
        <td>
          StartAll
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record starts acquisition on all of the MCA records in this system
          without first erasing any existing spectra. In the mapping modes it starts a new
          mapping run.
        </td>
      </tr>
      <tr valign="top">
        <td>
          StopAll
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record stops acquisition in MCA and mapping modes.
        </td>
      </tr>
      <tr>
        <td align="center" colspan="3">
          <b>Preset Control Records</b>
        </td>
      </tr>
      <tr valign="top">
        <td>
          PresetMode
        </td>
        <td>
          mbbo
        </td>
        <td>
          The preset counting mode. The choices are:
          <ul>
            <li>"No preset" Count until acquisition is stopped manually.</li>
            <li>"Real time" Count for a preset real time. The real time is set by the PresetReal
              record.</li>
            <li>"Events" The output of the digital baseline filter. The preset number of events
              is set by the PresetEvents record.</li>
            <li>"Triggers" The preset number of triggers is set by the PresetTriggers record.</li>
          </ul>
        </td>
      </tr>
      <tr valign="top">
        <td>
          PresetReal
        </td>
        <td>
          ao
        </td>
        <td>
          The preset real time.
        </td>
      </tr>
      <tr valign="top">
        <td>
          PresetEvents
        </td>
        <td>
          longout
        </td>
        <td>
          The number of events to count for.
        </td>
      </tr>
      <tr valign="top">
        <td>
          PresetTriggers
        </td>
        <td>
          longout
        </td>
        <td>
          The number of triggers to count for.
        </td>
      </tr>
      <tr>
        <td align="center" colspan="3">
          <b>Status/Statistics Records</b>
        </td>
      </tr>
      <tr valign="top">
        <td>
          StatusAll
        </td>
        <td>
          ai
        </td>
        <td>
          Processing this record causes the status information (Acquiring, ElapsedReal, etc.)
          to be read. For maximum performance with short count times this record should have
          .SCAN=Passive. When this record is Passive the status information will still be
          read once when acquisition completes in normal MCA mode.
        </td>
      </tr>
      <tr valign="top">
        <td>
          ReadAll
        </td>
        <td>
          ai
        </td>
        <td>
          Processing this record causes the MCA spectra to be read. For maximum performance
          with short count times this record should have .SCAN=Passive. When this record is
          Passive the MCA spectra will still be read once when acquisition completes in normal
          MCA mode. However, in order for the MCA spectra update in the MCA mapping mode this
          record must be set to periodically process (e.g. "2 second").
        </td>
      </tr>
      <tr valign="top">
        <td>
          Acquiring
        </td>
        <td>
          bi
        </td>
        <td>
          Acquisition status, 0=Done, 1=Acquiring. Acquiring will be 1 if any channel is acquiring.
        </td>
      </tr>
      <tr valign="top">
        <td>
          MaxElapsedReal
        </td>
        <td>
          ai
        </td>
        <td>
          The maximum of the elapsed real time of all system channels.
        </td>
      </tr>
      <tr valign="top">
        <td>
          MaxElapsedLive
        </td>
        <td>
          ai
        </td>
        <td>
          The maximum of the elapsed live time of all system channels.
        </td>
      </tr>
      <tr valign="top">
        <td>
          MaxElapsedTriggerLive
        </td>
        <td>
          ai
        </td>
        <td>
          The maximum of the elapsed trigger live time of all system channels.
        </td>
      </tr>
      <tr valign="top">
        <td>
          MaxTriggers
        </td>
        <td>
          ai
        </td>
        <td>
          The maximum of the triggers of all system channels.
        </td>
      </tr>
      <tr valign="top">
        <td>
          MaxEvents
        </td>
        <td>
          ai
        </td>
        <td>
          The maximum of the events of all system channels.
        </td>
      </tr>
      <tr valign="top">
        <td>
          MaxInputCountRate
        </td>
        <td>
          ai
        </td>
        <td>
          The maximum of the input count rate of all system channels.
        </td>
      </tr>
      <tr valign="top">
        <td>
          MaxOutputCountRate
        </td>
        <td>
          ai
        </td>
        <td>
          The maximum of the output count rate of all system channels.
        </td>
      </tr>
      <tr valign="top">
        <td>
          DeadTime
        </td>
        <td>
          ai
        </td>
        <td>
          The dead time. This value is the average of the dead time of all system channels.
          The dead time of each MCA is the cumulative dead time since the MCA was last erased.
        </td>
      </tr>
      <tr valign="top">
        <td>
          IDeadTime
        </td>
        <td>
          ai
        </td>
        <td>
          The instantaneous dead time. This value is the average of the intantaneous dead
          time of all system channels. The instantaneous dead time of each MCA is the dead
          time in the interval since the MCA status was last read.
        </td>
      </tr>
      <tr>
        <td align="center" colspan="3">
          <b>High-Level Parameter Records</b>
        </td>
      </tr>
      <tr valign="top">
        <td>
          CopyDetectionThreshold
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record copies the DetectionThreshold from channel 1 to all channels.
        </td>
      </tr>
      <tr valign="top">
        <td>
          CopyMinPulsePairSeparation
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record copies the MinPulsePairSeparation from channel 1 to all
          channels.
        </td>
      </tr>
      <tr valign="top">
        <td>
          CopyDetectionFiler
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record copies the DetectionFilter from channel 1 to all channels.
        </td>
      </tr>
      <tr valign="top">
        <td>
          CopyScaleFactor
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record copies the ScaleFactor from channel 1 to all channels.
        </td>
      </tr>
      <tr valign="top">
        <td>
          CopyRisetimeOptimization
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record copies the RisetimeOptimization from channel 1 to all channels.
        </td>
      </tr>
      <tr valign="top">
        <td>
          CopyDetectorPolarity
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record copies the DetectorPolarity from channel 1 to all channels.
        </td>
      </tr>
      <tr valign="top">
        <td>
          CopyResetDelay
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record copies the ResetDelay from channel 1 to all channels.
        </td>
      </tr>
      <tr valign="top">
        <td>
          CopyDecayTime
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record copies the DecayTime from channel 1 to all channels.
        </td>
      </tr>
      <tr valign="top">
        <td>
          CopyResetDelay
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record copies the ResetDelay from channel 1 to all channels.
        </td>
      </tr>
      <tr valign="top">
        <td>
          CopyDecayTime
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record copies the DecayTime from channel 1 to all channels.
        </td>
      </tr>
      <tr valign="top">
        <td>
          ReadTraces
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record reads the TraceData for all channels. <i>Note: this record
            should be set to Passive during normal data acquisition, or it will slow things
            down.</i>
        </td>
      </tr>
      <tr>
        <td align="center" colspan="3">
          <b>ROI and SCA Records</b>
        </td>
      </tr>
      <tr valign="top">
        <td>
          CopyROIChannel
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record copies all ROIs from channel 1 to all channels on a channel-by-channel
          basis.
        </td>
      </tr>
      <tr valign="top">
        <td>
          CopyROIEnergy
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record copies all ROIs from channel 1 to all channels on an energy-by-energy
          basis, i.e. using the energy calibration information for each MCA.
        </td>
      </tr>
      <tr valign="top">
        <td>
          CopyROI_SCA
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record copies every ROI for every channel to the corresponding
          SCA.
        </td>
      </tr>
    </tbody>
  </table>
  <h3 id="dxpMapping">
    dxpMapping.template</h3>
  <p>
    The following records are defined in the database dxpMapping.template. One instance
    of this database is loaded for a FalconX system, since they control system-wide
    mapping parameters.</p>
  <p>
    This document does not attempt to explain the mapping mode features of the FalconX
    that these records control. The user should read the <a href="FalconXn Mapping Buffer Specification.pdf">
      FalconX mapping document</a> to understand the mapping features. Note that the
    document says that list mode mapping is supported, but this is not yet the case,
    currently only MCA mapping is supported by the XIA Handel library.</p>
  <p>
    All of the record names in the template file are preceeded by the macro parameter
    $(P), the prefix for this detector system.</p>
  <table border="1" cellpadding="5">
    <tbody>
      <tr>
        <td align="center" colspan="3">
          <b>Records in dxpMapping.template</b>
        </td>
      </tr>
      <tr>
        <th>
          Record Name
        </th>
        <th>
          Record Type
        </th>
        <th>
          Description
        </th>
      </tr>
      <tr>
        <td align="center" colspan="3">
          <b>Mapping Mode Control Records</b>
        </td>
      </tr>
      <tr valign="top">
        <td>
          CollectMode<br />
          CollectMode_RBV
        </td>
        <td>
          mbbo<br />
          mbbi
        </td>
        <td>
          Selects the collection mode for the system. The choices are:
          <ul>
            <li>"MCA spectra" Normal MCA spectra mode where individual spectra are collected with
              the MCA record.</li>
            <li>"MCA mapping" MCA mapping mode where MCA spectra are collected into the double-buffered
              memory.</li>
          </ul>
          Note: In the future List mapping will probably also be supported.
        </td>
      </tr>
      <tr valign="top">
        <td>
          NDArrayMode<br />
          NDArrayMode_RBV
        </td>
        <td>
          mbbo<br />
          mbbi
        </td>
        <td>
          Selects how the mapping data is stored in NDArrays, and thus the structure of the
          data when written to disk. The choices are:
          <ul>
            <li>"Raw buffers" Each NDArray contains the raw buffers as read from the Handel library.
              The NDArray will have dimensions [bufferSize, numDetectors]. Each buffer contains
              the spectra for N pixels, as well as the real-time and live-time information for
              each pixel. This is the way the xMAP and Mercury drivers in the dxp module output
              mapping data. There are minor differences in the mapping buffer structures between
              the FalconX and the xMAP/Mercury. IDL software to decode the FalconX mapping buffers
              is available and is described below.</li>
            <li>"MCA spectra" The buffers are decoded into MCA spectra and real-time and live-time
              information. Each NDArray is of dimensions [numMCAChannels, numDetectors]. The real-time
              and live-time information is attached the NDArray as NDAttributes. This is the format
              in which the Xspress3 driver outputs data, so applications written to work with
              the Xspress3 should work with this mode.</li>
          </ul>
        </td>
      </tr>
      <tr valign="top">
        <td>
          PixelAdvanceMode<br />
          PixelAdvanceMode_RBV
        </td>
        <td>
          mbbo<br />
          mbbi
        </td>
        <td>
          Selects the pixel advance mode for system. The choices are:
          <ul>
            <li>"User" The NextPixel record is used for pixel advance.</li>
            <li>"Gate" Transitions on the Gate hardware input signal are used to drive the pixel
              advance. .</li>
          </ul>
        </td>
      </tr>
      <tr valign="top">
        <td>
          NextPixel
        </td>
        <td>
          bo
        </td>
        <td>
          Writing 1 to this record causes the system to advance to the next pixel in MCA mapping
          mode. This is a "software" pixel advance, and can be issued any time mapping mode
          acquisition is in progress, regardless of the setting of PixelAdvanceMode.
        </td>
      </tr>
      <tr valign="top">
        <td>
          PixelsPerRun<br />
          PixelsPerRun_RBV
        </td>
        <td>
          longout<br />
          longin
        </td>
        <td>
          The total number of pixels to acquire in one "run" when acquisition starts. If this
          value is -1 then there is no preset number of pixels, and acquisition will continue
          forever until it is stopped manually with StopAll.
        </td>
      </tr>
      <tr valign="top">
        <td>
          PixelsPerBuffer<br />
          PixelsPerBuffer_RBV
        </td>
        <td>
          longout<br />
          longin
        </td>
        <td>
          The number of pixels per buffer. If AutoPixelsPerBuffer=Manual, then this value
          is used, rather than using the maximum possible value computed when AutoPixelsPerBuffer=Auto.
          The main reason to set this value manually is that the updates to statistics and
          MCA displays in mapping mode happen only when a buffer is read out. If the time
          per pixel is relatively long then decreasing PixelsPerBuffer will result in more
          frequent updates of the MCA and statistics displays. Setting this value too low
          when doing rapid mapping can result in buffer overflow. PixelsPerBuffer_RBV always
          contains the actual number of pixels per buffer.
        </td>
      </tr>
      <tr valign="top">
        <td>
          AutoPixelsPerBuffer<br />
          AutoPixelsPerBuffer_RBV
        </td>
        <td>
          mbbo<br />
          mbbi
        </td>
        <td>
          Flag controlling how the number of pixels per buffer is determined. Choices are
          0=Manual and 1=Auto. If Manual is selected then the number of pixels per buffer
          is controlled by the PixelsPerBuffer record. If Auto is selected then the maximum
          number of pixels that the mapping buffer can hold is automatically computed.
        </td>
      </tr>
      <tr valign="top">
        <td>
          BufferSize_RBV
        </td>
        <td>
          longin
        </td>
        <td>
          The size of the buffer being used in units of 32-bit words. This will be the first
          dimension of the array passed to the plugins when a buffer is read out. The maximum
          value is 4456704 but it can be less than this depending on the value of PixelsPerBuffer_RBV.
        </td>
      </tr>
      <tr valign="top">
        <td>
          IgnoreGate<br />
          IgnoreGate_RBV
        </td>
        <td>
          mbbo<br />
          mbbi
        </td>
        <td>
          Flag controlling whether the Gate input signal is used to inhibit counting. Choices
          are 0=No and 1=Yes. If IgnoreGate=Yes then the Gate input can be used as a pixel
          advance signal, but its high or low state will not influence whether counting is
          enabled, i.e. only the transitions are significant. If IgnoreGate=No then counting
          will be inhibited when the Gate input is low (if InputLogicPolarity=Normal) or high
          (if InputLogicPolarity=Inverted). NOTE: Although this record is in dxpMapping.template
          with recent FalconX firmware IgnoreGate also controls the behavior of the gate input
          in normal MCA mode, not only in mapping mode.
        </td>
      </tr>
      <tr valign="top">
        <td>
          InputLogicPolarity<br />
          InputLogicPolarity_RBV
        </td>
        <td>
          mbbo<br />
          mbbi
        </td>
        <td>
          Flag controlling the polarity of the Gate input signal. Choices are 0=Normal, 1=Inverted.
          In Normal mode a low level on the Gate input inhibits counting (if IgnoreGate=No)
          and a high-to-low transition performs a pixel advance (if PixelAdvanceMode=Gate).
          In Inverted mode these levels are the opposite, i.e. a high level inhibits counting
          and a low-to-high transition performs a pixel advance. NOTE: Although this record
          is in dxpMapping.template with recent FalconX firmware InputLogicPolarity also controls
          the behavior of the gate input in normal MCA mode, not only in mapping mode.
        </td>
      </tr>
      <tr valign="top">
        <td>
          SyncCount<br />
          SyncCount_RBV
        </td>
        <td>
          longout<br />
          longin
        </td>
        <td>
          The divisor used on the Gate input for pixel advance if PixelAdvanceMode=Gate. This
          value can be used to divide the Gate clock. For example, if the Gate input were
          connected to the pulse output of a stepper motor controller, then setting SyncCount=10
          would perform a pixel advance on every 10'th stepper motor pulse. SyncCount=1 results
          in no clock division, i.e. every Sync input pulse results in a pixel advance.
        </td>
      </tr>
      <tr valign="top">
        <td>
          ReadRate_RBV
        </td>
        <td>
          ai
        </td>
        <td>
          The burst read rate in MBytes/s measured when reading the mapping data from each
          module.
        </td>
      </tr>
      <tr valign="top">
        <td>
          MBytesRead_RBV
        </td>
        <td>
          ai
        </td>
        <td>
          The total number of MBytes of mapping data read from all modules since the IOC started.
        </td>
      </tr>
    </tbody>
  </table>
  <h2 id="Mapping_Mode">
    Using mapping mode</h2>
  <p>
    In the mapping mode data are collected into a double-buffered memory on the module.
    When one half of the buffer memory is full the EPICS driver reads the data from
    that buffer and converts it into an <a href="https://cars.uchicago.edu/software/epics/areaDetectorDoc.html#NDArray">
      NDArray object.</a> If NDArrayMode=Raw buffers then there is no conversion of
    the buffer when it is copied to the NDArray. If NDArrayMode=MCA spectra then the
    buffer is unpacked into an NDArray of dimensions [numMCAChannels, numDetectors].
    The driver then calls any registered <a href="https://cars.uchicago.edu/software/epics/pluginDoc.html">
      plugins</a> with that NDArray. The plugins will typically be one of the <a href="https://cars.uchicago.edu/software/epics/NDPluginFile.html">
        NDPluginFile</a> plugins which will write the data to disk. The useful file
    plugins can write the data in netCDF, NeXus/HDF5, and TIFF formats. The JPEG plugin
    will not be useful, because the data are not images. The data can also be passed
    to the <a href="https://cars.uchicago.edu/software/epics/NDPluginStdArrays.html">NDPluginStdArrays</a>
    plugin which can make the data available to EPICS channel access clients as waveform
    records.</p>
  <p>
    When NDArrayMode=Raw buffers the data in each NDArray object is a 32-bit unsigned
    integer array with dimensions [BufferSize, NumDetectors]. BufferSize is the size
    of the double-buffered memory in use, which is controlled by the AutoPixelsPerBuffer
    and PixelsPerBuffer records. It has a maximum value of 4456704 but can be smaller
    than this. In MCA mapping mode the buffer for each module in this array contains
    the data for each pixel, including the elapsed live and real time, triggers and
    events, and the MCA data. In List mapping mode the buffer will contain the event
    data for each x-ray event. The details of the buffer structure are beyond the scope
    of this document, but the buffer structure is thoroughly described in the <a href="FalconXn Mapping Buffer Specification.pdf">
      FalconX mapping document</a>.
  </p>
  <p>
    To collect mapping mode data one would typically execute the following steps:</p>
  <ol>
    <li>Select the MCA mapping mode (CollectMode record)</li>
    <li>Select the pixel advance mode (PixelAdvanceMode record)</li>
    <li>Select the number of pixels per run (PixelsPerRun record)</li>
    <li>In the netCDF or HDF5 plugin
      <ul>
        <li>Set the Enable record to Enable.</li>
        <li>Set the FilePath, FileName, FileNumber, FileTemplate, AutoIncrement, FileWriteMode,
          NumCapture, and Autosave records to the desired values. Typically AutoIncrement=Yes,
          FileWriteMode=Stream, NumCapture= number of buffers to be captured = PixelsPerRun/PixelsPerBuffer.</li>
        <li>If FileWriteMode is Stream then start capture/streaming with the Capture record.
          <i>NOTE: Before stream or capture can be started there must have been at least 1 callback
            to the plugin in the current mapping mode with the same CollectMode and PixelsPerBuffer
            currently in use. This is because stream and capture modes need to know the buffer
            size that will be received at the time that capture/streaming is started. This can
            be done by simply enabling the file plugin and doing a quick run. Just start a run,
            advance a few pixels with the NextPixel record, and stop the run. Even though only
            a few pixels have been collected the entire buffer is read out, so the size is correct.</i></li>
      </ul>
    </li>
    <li>Start acquisition with the EraseStart record.</li>
    <li>Do something that causes the pixels to advance. This could be using the NextPixel
      record, or an external advance source such as a pulse generator, motor pulse train,
      etc.</li>
    <li>Each time a buffer fills up the file plugin will be called, writing data to disk.</li>
    <li>Each time the buffer fills up the MCA spectra for the first pixel in that buffer
      will be sent to the MCA records, so they can be displayed. This provides a periodic
      visual feedback on the MCA data.</li>
    <li>Once the requested number of pixels per run has occured acquisition will automatically
      stop.</li>
    <li>If the file plugin is in stream mode and NumCapture was specified correctly, then
      it will also automatically stop capturing when the last buffer is received. If NumCapture
      was 0 or was too large, then stream/capture should be manually stopped by writing
      0 to the Capture record.</li>
  </ol>
  <p>
    Data acquisition in mapping mode is very flexible. When doing a 2-D map, for example,
    one could stream the data for the entire map into a single large netCDF file. Alternatively,
    one could save just a single scan row into each file, and restart the file plugin
    for each row, using a new file name, or auto-increment on the file number. Data
    can be saved into HDF5, NeXus, netCDF or TIFF files.</p>
  <p>
    There are IDL functions available in the <a href="https://cars.uchicago.edu/software/idl/detectors.html">
      CARS IDL detector package</a> to conveniently extract the mapping mode data from
    netCDF files produced with the netCDF plugin. <a href="https://cars.uchicago.edu/software/idl/detector_routines.html#read_nd_netcdf">
      read_nd_netcdf.pro</a> reads the data from a netCDF file written by the areaDetector
    NDFileNetCDF plugin. If raw buffers were written to the file then <a href="https://cars.uchicago.edu/software/idl/detector_routines.html#decode_falcon_buffers">
      decode_falcon_buffers.pro</a> can be used to decode the data.</p>
  <h3 id="medm">
    medm screens</h3>
  <p>
    The following are screen shots of the medm screens for the FalconX.</p>
  <div style="text-align: center">
    <h3>
      SITORO_Top.adl</h3>
    <p>
      Top-level screen to load the main control screens for the example IOCs.</p>
    <p>
      <img alt="SITORO_Top.png" src="SITORO_Top.png" /></p>
    <hr />
  </div>
  <div style="text-align: center">
    <h3>
      4element_SITORO.adl</h3>
    <p>
      Main screen for Falcon4.</p>
    <p>
      <img alt="4element_SITORO.png" src="4element_SITORO.png" /></p>
    <hr />
  </div>
  <div style="text-align: center">
    <h3>
      4element_DetectorSetup_SITORO.adl</h3>
    <p>
      Detector setup screen for Falcon4.</p>
    <p>
      <img alt="4element_DetectorSetup_SITORO.png" src="4element_DetectorSetup_SITORO.png" /></p>
    <hr />
  </div>
  <div style="text-align: center">
    <h3>
      4element_Plots_SITORO.adl</h3>
    <p>
      Screen showing all 4 MCA spectra for the Falcon4.</p>
    <p>
      <img alt="4element_Plots_SITORO.png" src="4element_Plots_SITORO.png" /></p>
    <hr />
  </div>
  <div style="text-align: center">
    <h3>
      simple_MCA_SITORO.adl</h3>
    <p>
      Single detector MCA display screen for Falcon4.</p>
    <p>
      <img alt="simple_MCA_SITORO.png" src="simple_MCA_SITORO.png" /></p>
    <hr />
  </div>
  <div style="text-align: center">
    <h3>
      4element_trace_SITORO.adl</h3>
    <p>
      Screen showing all 4 ADC trace plots for Falcon4.</p>
    <p>
      <img alt="4element_trace_SITORO.png" src="4element_trace_SITORO.png" /></p>
    <hr />
  </div>
  <div style="text-align: center">
    <h3>
      SITORO_trace.adl</h3>
    <p>
      Screen showing ADC trace plot for a single channel on the Falcon4.</p>
    <p>
      <img alt="SITORO_trace.png" src="SITORO_trace.png" /></p>
    <hr />
  </div>
  <div style="text-align: center">
    <h3>
      4element_ROI_SCA_SITORO.adl</h3>
    <p>
      Screen to display ROI and SCA for a single ROI/SCA on each channel of the Falcon4.</p>
    <p>
      <img alt="4element_ROI_SCA_SITORO.png" src="4element_ROI_SCA_SITORO.png" /></p>
    <hr />
  </div>
  <div style="text-align: center">
    <h3>
      4element_cal_SITORO.adl</h3>
    <p>
      Screen to display calibration parameters for each channel on the Falcon4.</p>
    <p>
      <img alt="4element_cal_SITORO.png" src="4element_cal_SITORO.png" /></p>
    <hr />
  </div>
  <div style="text-align: center">
    <h3>
      4element_SITORO_presets.adl</h3>
    <p>
      Screen to control the preset parameters for each channel on the Falcon4.</p>
    <p>
      <img alt="4element_SITORO_presets.png" src="4element_SITORO_presets.png" /></p>
    <hr />
  </div>
  <div style="text-align: center">
    <h3>
      4element_SITORO_statistics.adl</h3>
    <p>
      Screen to display the elapsed statistics for each channel on the Falcon4.</p>
    <p>
      <img alt="4element_SITORO_statistics.png" src="4element_SITORO_statistics.png" /></p>
    <hr />
  </div>
  <div style="text-align: center">
    <h3>
      mappingControl_SITORO.adl</h3>
    <p>
      Screen to control the mapping modes on the Falcon4.</p>
    <p>
      <img alt="mappingControl_SITORO.png" src="mappingControl_SITORO.png" /></p>
    <hr />
  </div>
  <div style="text-align: center">
    <h3>
      HDF5_SITORO.adl</h3>
    <p>
      Screen to control the HDF5 plugin for saving mapping mode data on the Falcon4.</p>
    <p>
      <img alt="HDF5_SITORO.png" src="HDF5_SITORO.png" /></p>
    <hr />
  </div>
  <h2 id="Installing">
    Installing the EPICS dxpSITORO software</h2>
  <p>
    To install the dxpSITORO software first decide whether you want to build the software
    from source code, or install the pre-built binaries. The Windows binaries should
    run on almost any version of Windows. The Linux binaries are normally built with
    Redhat RHEL7, but builds for other Linux versions can be provides on request.</p>
  <p>
    Building from the source code requires downloading <a href="http://www.aps.anl.gov/epics/base/index.php">
      EPICS base</a> and all of the required <a href="http://www.aps.anl.gov/aod/bcda/synApps/index.php">
        synApps components</a>, including <a href="https://github.com/areaDetector/ADCore">
          areaDetector/ADCore</a> and <a href="https://github.com/areaDetector/ADSupport">ADSupport</a>.
    To build from source code on Windows requires Microsoft Visual Studio 2015 or later,
    plus perl and GNU make. It is beyond the scope of this document to describe how
    to build the source code. Consult other EPICS documentation for this.</p>
  <p>
    The dxpSITORO software provides example IOC directory, iocBoot/FalconX. This create
    EPICS process variables with names like dxpSITORO:dxp1:DetectorPolarity, where dxpSITORO
    is the "prefix" for the process variable names, dxp1 is for the first detector channel,
    and DetectorPolarity is the parameter being controller. This prefix would be OK
    for installations where there will be at most one FalconX on the subnet. However,
    in many cases there will be the possibility of more than one FalconX module running
    EPICS on the same subnet. If this is the case then it is essential that each one
    use a different prefix, because EPICS process variable names must be unique on a
    subnet. The following is how to give your IOC a unique prefix, and still be able
    to upgrade the EPICS software easily. It is recommended that you follow these instructions
    even if you don't have name conflicts on your subnet, so that files you edit are
    in a directory that will not be overwritten when you upgrade the EPICS software.</p>
  <ul>
    <li>Make a copy of the iocFalconX directory, for example to ioc13IDD_FalconX.</li>
    <li>Edit all files in that directory (including 4element.cmd, 4element.substitutions,
      and START_IOC*), changing all occurances of the prefix dxpSITORO: to another prefix,
      for example to the prefix 13IDD_SITORO:.</li>
    <li>If you have created any higher-level medm screens that load the medm screens in
      this package, you will need to edit them to pass the new prefix.</li>
    <li>The next time you unpack a new version of the EPICS dxpSITORO software it will
      overwrite the iocFalconX directory. However, if you have made your own new directory
      that will not be modified.</li>
  </ul>
  <p>
    The dxpSITORO application uses the EPICS save/restore facility. This means that
    all of the important parameters that you might change when running the software
    are saved in files in the subdirectory called autosave/ under your IOC directory.
    These parameters include the peaking time, the update rates for displays and many
    other parameters. The next time EPICS is started it will restore these values automatically
    from the file called autosave/auto_settings4.sav. It is a good idea to make copies
    of this file from time to time so that you can get back to old settings if the file
    is lost or corrupted.</p>
  <p>
    Even if the EPICS IOC will be run on Linux it is advisable to install have a Windows
    PC on which you should install the latest version of the Prospect software from
    XIA. ProSpect is needed to "characterize" the detector, which measures the pulse
    shape from each detector element and derives a model to fit the shape. ProSpect
    can also run a Configuration Wizard that will create an initial .ini file with the
    correct settings for your system. You can copy that file to the iocFalconX directory
    or edit the falconxn4.ini file there. It is useful to have ProSpect available on
    the computer to compare with the EPICS software.</p>
  <p>
    Copy all of the medm .adl files into a single directory. This is simpler than defining
    EPICS_DISPLAY_PATH to point to all of the required directories. For example, if
    you decide to put the .adl files in ./epics_adls, and if you unpacked the synApps
    modules include areaDetector into ./epics/support and unpacked the dxpSITORO distribution
    into ./epics/support/dxpSITORO then type the following commands at the Linux or
    Cygwin bash shell prompt:</p>
  <pre>      $ mkdir ./epics_adls
      $ find ./epics/support -name '*.adl' -exec cp -f -p -v {} ./epics_adls \;
      </pre>
  <p>
    Define the environment variable EPICS_DISPLAY_PATH to point to this epics_adls directory.
    For the Windows shell use the Windows Control Panel/System/Advanced/Environment
    Variables.</p>
  <p>
    If you installed pre-built binaries, rather than building from source, then edit
    the envPaths file in iocBoot/iocFalconX. Change the paths to the locations of the
    directories on your system. Don't worry about the path for directories that don't
    exist, like SNCSEQ, EPICS_BASE, etc.</p>
  <hr />
  <address>
    Suggestions and comments to: <a href="mailto:rivers@cars.uchicago.edu">Mark Rivers
    </a>: (rivers@cars.uchicago.edu)
  </address>
</body>
</html>
